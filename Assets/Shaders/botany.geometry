#version 400
#extension GL_EXT_geometry_shader4 : enable  

layout(triangles) in;
layout(triangle_strip, max_vertices = 30) out;

uniform sampler1D g_Random;

layout(std140) uniform PerFrame
{
	mat4 projectionMatrix;
	mat4 viewMatrix;
};

layout(std140) uniform Time
{
	float g_dt;
	float g_time;
};

in vec3 gs_normal_in[];
in float gs_density_in[];
in float gs_lod_in[];

out vec3 vert_normal1;
//out vec2 vert_texcoord1;
out vec3 vert_color1;

// LOD 1


// LOD 0

vec3 shortBlade[4] = vec3[]( 
    vec3(0.088837, 0.000000, 0.000000),
    vec3(-0.087622, 0.000000, 0.000000), 
    vec3(0.038313, 0.227795, 0.070106),
    vec3(-0.087622, 0.374425, 0.263618)
);

vec3 mediumBlade[5] = vec3[]( 
    vec3(-0.088230, 0.000000, 0.000000),
    vec3(0.088230, 0.000000, 0.000000), 
    vec3(-0.075922, 0.341586, -0.110473),
    vec3(0.075922, 0.341586, -0.110473),
    vec3(0.000000, 0.590890, -0.433083)
);

vec3 longBlade[7] = vec3[]( 
    vec3(-0.088230, 0.000000, 0.000000),
    vec3(0.088230, 0.000000, 0.000000), 
    vec3(-0.088230, 0.341586, -0.009296),
    vec3(0.088230, 0.341586, -0.009296),
    vec3(-0.075922, 0.630581, -0.062587),
    vec3(0.075922, 0.630581, -0.062587),
    vec3(0.000000, 0.999042, -0.226456)
);

vec2 pattern[20] = vec2[]( 
    vec2(0,0),
    vec2(0.1,0),
    vec2(0.2,0),
    vec2(0.3,0),
    vec2(0.4,0),
    vec2(0.5,0),
    vec2(0.1,0.1),
    vec2(0.2,0.2),
    vec2(0.3,0.3),
    vec2(0.4,0.4),
    vec2(0.5,0.5),
    vec2(0,0.1),
    vec2(0,0.2),
    vec2(0,0.3),
    vec2(0,0.4),
    vec2(0,0.5),
    vec2(0.1,0.2),
    vec2(0.2,0.3),
    vec2(0.3,0.4),
    vec2(0.4,0.5)
);

vec2 pattern2[20] = vec2[]( 
    vec2(0.45,0.45),
    vec2(0.35,0.35),
    vec2(0.30,0.30),
    vec2(0.5,0.5),
    vec2(0.45,0.55),
    vec2(0.40,0.60),
    vec2(0.30,0.70),
    vec2(0.70,0.30),
    vec2(0.60,0.40),
    vec2(0.40,0.60),
    vec2(0.43,0.72),
    vec2(0.56,0.42),
    vec2(0.25,0.75),
    vec2(0.75,0.25),
    vec2(0.53,0.23),
    vec2(0.19,0.45),
    vec2(0.18,0.72),
    vec2(0.32,0.41),
    vec2(0.25,0.67),
    vec2(0.69,0.23)
);

float random(vec3 seed, int i){
     vec4 seed4 = vec4(seed, i);
     float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));
     return fract(sin(dot_product) * 43758.5453);
}

void CreateShortBlade(vec3 position, float angle)
{  
    vec4 unit = vec4(0,0,1,0);
    mat4 rotation;
	rotation[0] = vec4(cos(angle), 0, sin(angle), 0);
	rotation[1] = vec4(0, 1, 0, 0);
	rotation[2] = vec4(-sin(angle), 0, cos(angle), 0);
	rotation[3] = vec4(0, 0, 0, 1);   
    unit = rotation * unit;

    int i;
    for(i = 0; i < 4; i++)
    {
        vec4 pos = rotation * vec4(shortBlade[i], 0.0);
        pos += vec4(position, 1.0);
        
        gl_Position = projectionMatrix * viewMatrix * pos;
        vert_normal1 = gs_normal_in[0];
        vert_color1 = vec3(1,0,0);
        EmitVertex();
    }
    EndPrimitive();
}

void CreateShortBladeLOD(vec3 position, float angle)
{  
    vec4 unit = vec4(0,0,1,0);
    mat4 rotation;
	rotation[0] = vec4(cos(angle), 0, sin(angle), 0);
	rotation[1] = vec4(0, 1, 0, 0);
	rotation[2] = vec4(-sin(angle), 0, cos(angle), 0);
	rotation[3] = vec4(0, 0, 0, 1);   
    unit = rotation * unit;

    int i;
    for(i = 0; i < 4; i++)
    {
        vec4 pos = rotation * vec4(shortBlade[i], 0.0);
        pos += vec4(position, 1.0);
        
        gl_Position = projectionMatrix * viewMatrix * pos;
        vert_normal1 = gs_normal_in[0];
        vert_color1 = vec3(1,1,0);
        EmitVertex();
    }
    EndPrimitive();
}

void CreateShortBladeLOD2(vec3 position, float angle)
{  
    vec4 unit = vec4(0,0,1,0);
    mat4 rotation;
	rotation[0] = vec4(cos(angle), 0, sin(angle), 0);
	rotation[1] = vec4(0, 1, 0, 0);
	rotation[2] = vec4(-sin(angle), 0, cos(angle), 0);
	rotation[3] = vec4(0, 0, 0, 1);   
    unit = rotation * unit;

    int i;
    for(i = 0; i < 4; i++)
    {
        vec4 pos = rotation * vec4(shortBlade[i], 0.0);
        pos += vec4(position, 1.0);
        
        gl_Position = projectionMatrix * viewMatrix * pos;
        vert_normal1 = gs_normal_in[0];
        vert_color1 = vec3(1,0,1);
        EmitVertex();
    }
    EndPrimitive();
}

void CreateMediumBlade(vec3 position, float angle)
{  
    vec4 unit = vec4(0,0,1,0);
    mat4 rotation;
	rotation[0] = vec4(cos(angle), 0, sin(angle), 0);
	rotation[1] = vec4(0, 1, 0, 0);
	rotation[2] = vec4(-sin(angle), 0, cos(angle), 0);
	rotation[3] = vec4(0, 0, 0, 1);   
    unit = rotation * unit;

    int i;
    for(i = 0; i < 5; i++)
    {
        vec4 pos = rotation * vec4(mediumBlade[i], 0.0);
        pos += vec4(position, 1.0);
        
        gl_Position = projectionMatrix * viewMatrix * pos;
        vert_normal1 = gs_normal_in[0];
        vert_color1 = vec3(0,1,0);
        EmitVertex();
    }
    EndPrimitive();
}

void CreateLongBlade(vec3 position, float angle)
{     
    vec4 unit = vec4(0,0,1,0);
    mat4 rotation;
	rotation[0] = vec4(cos(angle), 0, sin(angle), 0);
	rotation[1] = vec4(0, 1, 0, 0);
	rotation[2] = vec4(-sin(angle), 0, cos(angle), 0);
	rotation[3] = vec4(0, 0, 0, 1);   
    unit = rotation * unit;

    int i;
    for(i = 0; i < 7; i++)
    {
        vec4 pos = rotation * vec4(longBlade[i], 0.0);
        pos += vec4(position, 1.0);
    
        gl_Position = projectionMatrix * viewMatrix * pos;
        vert_normal1 = gs_normal_in[0];
        vert_color1 = vec3(0,0,1);
        EmitVertex();
    }
    EndPrimitive();
}

void CreateImposter(vec3 position)
{
    vec3 scale = vec3(1.8, 0.8, 1.8);
	vec4 vertices[4];  
	vertices[0] = vec4(position.x + scale.x, position.y + 2 * scale.y, position.z + scale.z, 1.0f);  
	vertices[1] = vec4(position.x - scale.x, position.y + 2 * scale.y, position.z - scale.z, 1.0f);   
	vertices[2] = vec4(position.x + scale.x, position.y, position.z + scale.z, 1.0f);  
	vertices[3] = vec4(position.x - scale.x, position.y, position.z - scale.z, 1.0f);

    vec2 texCoords[4];
	texCoords[0] = vec2(0,0);
	texCoords[1] = vec2(1,0);
	texCoords[2] = vec2(0,1);
	texCoords[3] = vec2(1,1);

    // Output four vertices.
    int i;
    for(i = 0; i < 4; i++)
    {
        gl_Position = projectionMatrix * viewMatrix * vertices[i];
        //vert_texcoord1 = texCoords[i];
        vert_normal1 = gs_normal_in[0];
        vert_color1 = vec3(0,0,1);
        EmitVertex();
    }
    
    EndPrimitive();   
}

void CreateQuad(vec3 position, float angle)
{
    vec4 unit = vec4(0,0,1,0);
    mat4 rotation;
	rotation[0] = vec4(cos(angle), 0, sin(angle), 0);
	rotation[1] = vec4(0, 1, 0, 0);
	rotation[2] = vec4(-sin(angle), 0, cos(angle), 0);
	rotation[3] = vec4(0, 0, 0, 1);   
    unit = rotation * unit;

    vec3 scale = vec3(1.8, 0.8, 1.8);
	vec4 vertices[4];  
	vertices[0] = vec4(position.x + unit.x * scale.x, position.y + 2 * scale.y, position.z + unit.z * scale.z, 1.0f);  
	vertices[1] = vec4(position.x - unit.x * scale.x, position.y + 2 * scale.y, position.z - unit.z * scale.z, 1.0f);   
	vertices[2] = vec4(position.x + unit.x * scale.x, position.y, position.z + unit.z * scale.z, 1.0f);  
	vertices[3] = vec4(position.x - unit.x * scale.x, position.y, position.z - unit.z * scale.z, 1.0f);

    vec2 texCoords[4];
	texCoords[0] = vec2(0,0);
	texCoords[1] = vec2(1,0);
	texCoords[2] = vec2(0,1);
	texCoords[3] = vec2(1,1);

    // Output four vertices.
    int i;
    for(i = 0; i < 4; i++)
    {
        gl_Position = projectionMatrix * viewMatrix * vertices[i];
        //vert_texcoord1 = texCoords[i];
        vert_normal1 = gs_normal_in[0];
        EmitVertex();
    }
    
    EndPrimitive();   
}

vec3 GetRandomPosition(vec3 a, vec3 b, vec3 ab, vec3 ac, int i)
{
   float r = random(a, i);
   float s = random(b, i);

   if(r + s >= 1)
    {
        r = 1 - r;
        s = 1 - s;
    }
   
    return a + r*ab + s*ac;
}

void main() 
{
    // Get average density.
    float avgDensity = gs_density_in[0];

    // Rejects triangles with low density.
    if(avgDensity < 0.2)
        return;
    
    // Triangle points.
    vec3 a = gl_in[0].gl_Position.xyz;
    vec3 b = gl_in[1].gl_Position.xyz;
    vec3 c = gl_in[2].gl_Position.xyz;
    
    // Calculate triangle vectors.
    vec3 ab = b-a;
    vec3 ac = c-a;
    
    // Calculate area.
    float area = length(cross(ab, ac)) / 2;
    
    if(area < 0.8)
        return;
    
    if(gs_lod_in[0] == 0)
    {
        if(avgDensity > 0.2)
        {
            float rotation = random(c, 0);
            CreateShortBlade(GetRandomPosition(a,b,ab,ac,0), 2*3.14*rotation);
        }
    
        if(avgDensity > 0.4)
        {
            float rotation = random(c, 1);
            CreateMediumBlade(GetRandomPosition(a,b,ab,ac,1), 2*3.14*rotation);
        }
    
        if(avgDensity > 0.6)
        {
            float rotation = random(c, 2);
            CreateLongBlade(GetRandomPosition(a,b,ab,ac,2), 2*3.14*rotation);
        }
        
        if(avgDensity > 0.8)
        {
            float rotation = random(c, 3);
            CreateLongBlade(GetRandomPosition(a,b,ab,ac,3), 2*3.14*rotation);
        }      
    }
    else if(gs_lod_in[0] == 1)
    {
        if(avgDensity > 0.2)
        {
            float rotation = random(c, 0);
            CreateShortBladeLOD(GetRandomPosition(a,b,ab,ac,0), 2*3.14*rotation);
        }
   
        if(avgDensity > 0.4)
        {
            float rotation = random(c, 1);
            CreateShortBladeLOD(GetRandomPosition(a,b,ab,ac,1), 2*3.14*rotation);
        }
    }
    else
    {
        if(avgDensity > 0.2)
        {
            float rotation = random(c, 0);
            CreateShortBladeLOD2(GetRandomPosition(a,b,ab,ac,0), 2*3.14*rotation);
        }
    }
}