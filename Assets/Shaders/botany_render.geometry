#version 400
#extension GL_EXT_geometry_shader4 : enable  

//#define SHOW_LOD
//#define SHOW_NORMALS

layout(points) in;
#ifdef SHOW_NORMALS
layout(line_strip, max_vertices = 10) out;
#else
layout(triangle_strip, max_vertices = 80) out;
#endif

layout(std140) uniform PerFrame
{
	mat4 projectionMatrix;
	mat4 viewMatrix;
    mat4 invView;
};

layout(std140) uniform Time
{
	float g_dt;
	float g_time;
};

layout(std140) uniform PerTech
{
    vec3 g_PlayerPosition;
};

in vec3 gs_normal_in[];
in float gs_density_in[];
in float gs_lod_in[];

out vec2 vert_texcoord1;
out vec3 vert_normal1;
out vec3 vert_color1;

// LOD 0

// Positions.
vec3 mediumBlade3[5] = vec3[](
    vec3(-0.146905, 0, 0.033582),
    vec3(-0.027772, 0, -0.096591),
    vec3(-0.220092, 0.341586, -0.050081),
    vec3(-0.117577, 0.341586, -0.162096),
    vec3(-0.406822, 0.590890, -0.323893)
);

// Texcoords.
vec2 mediumBlade3TC[5] = vec2[](
    vec2(0.999992, -0.000006),
    vec2(0.000008, -0.000006),
    vec2(0.930247, -0.578085),
    vec2(0.069754, -0.578085),
    vec2(0.500000, -0.999991)
);

// Normals.
vec3 mediumBlade3Normals[5] = vec3[](
    vec3(-0.701900, -0.307720, -0.642374),
    vec3(-0.701900, -0.307720, -0.642374),
    vec3(-0.612875, -0.556576, -0.560899),
    vec3(-0.612875, -0.556576, -0.560899),
    vec3(-0.451078, -0.791268, -0.412824)
);


void CreateMediumBlade3(vec3 position)
{
#ifdef SHOW_NORMALS
    int i;
    for(i = 0; i < 5; i++)
    {
        vec4 pos = vec4(position + mediumBlade3[i], 1.0);
        gl_Position = projectionMatrix * viewMatrix * pos;
        EmitVertex();

        vec3 normal = normalize(mediumBlade3Normals[i].xyz);   

        vec4 pos2 = vec4(position + mediumBlade3[i] + normal * 0.2, 1.0);
        gl_Position = projectionMatrix * viewMatrix * pos2;
        EmitVertex();
        EndPrimitive();
    }
#else

    float flipped = 1;
    vec3 normal = normalize(mediumBlade3Normals[0].xyz);
    vec3 cameraPos = (invView * vec4(0,0,0,1)).xyz;
    vec3 direction = vec3((position + mediumBlade3[0]) - cameraPos);
    if(dot(direction, normal) > 0)
        flipped = -1;
       
    int i;
    for(i = 0; i < 5; i++)
    {
        vec4 pos = vec4(position + mediumBlade3[i], 1.0);
        gl_Position = projectionMatrix * viewMatrix * pos;
     
        vec3 normal = normalize(mediumBlade3Normals[i].xyz);   
        vert_normal1 = (viewMatrix * vec4(normal, 0.0)).xyz;
        vert_normal1 *= flipped;
        vert_texcoord1 = mediumBlade3TC[i];

        EmitVertex();
    }
    EndPrimitive();
#endif
}

vec3 mediumBlade[5] = vec3[](
    vec3(0,0,0),
    vec3(0,0,0),
    vec3(0,0,0),
    vec3(0,0,0),
    vec3(0,0,0)
);

vec3 mediumBlade2[5] = vec3[](
    vec3(0,0,0),
    vec3(0,0,0),
    vec3(0,0,0),
    vec3(0,0,0),
    vec3(0,0,0)
);

vec3 tallBlade[7] = vec3[](
    vec3(0,0,0),
    vec3(0,0,0),
    vec3(0,0,0),
    vec3(0,0,0),
    vec3(0,0,0),
    vec3(0,0,0),
    vec3(0,0,0)
);

vec3 tallBlade2[7] = vec3[](
    vec3(0,0,0),
    vec3(0,0,0),
    vec3(0,0,0),
    vec3(0,0,0),
    vec3(0,0,0),
    vec3(0,0,0),
    vec3(0,0,0)
);

// OLD
/*vec3 shortBlade[4] = vec3[]( 
    vec3(0.088837, 0.000000, 0.000000),
    vec3(-0.087622, 0.000000, 0.000000), 
    vec3(0.038313, 0.227795, 0.070106),
    vec3(-0.087622, 0.374425, 0.263618)
);

vec3 mediumBlade[5] = vec3[]( 
    vec3(-0.088230, 0.000000, 0.000000),
    vec3(0.088230, 0.000000, 0.000000), 
    vec3(-0.075922, 0.341586, -0.110473),
    vec3(0.075922, 0.341586, -0.110473),
    vec3(0.000000, 0.590890, -0.433083)
);

vec3 longBlade[7] = vec3[]( 
    vec3(-0.088230, 0.000000, 0.000000),
    vec3(0.088230, 0.000000, 0.000000), 
    vec3(-0.088230, 0.341586, -0.009296),
    vec3(0.088230, 0.341586, -0.009296),
    vec3(-0.075922, 0.630581, -0.062587),
    vec3(0.075922, 0.630581, -0.062587),
    vec3(0.000000, 0.999042, -0.226456)
);*/

vec2 pattern[20] = vec2[]( 
    vec2(0,0),
    vec2(0.1,0),
    vec2(0.2,0),
    vec2(0.3,0),
    vec2(0.4,0),
    vec2(0.5,0),
    vec2(0.1,0.1),
    vec2(0.2,0.2),
    vec2(0.3,0.3),
    vec2(0.4,0.4),
    vec2(0.5,0.5),
    vec2(0,0.1),
    vec2(0,0.2),
    vec2(0,0.3),
    vec2(0,0.4),
    vec2(0,0.5),
    vec2(0.1,0.2),
    vec2(0.2,0.3),
    vec2(0.3,0.4),
    vec2(0.4,0.5)
);

vec2 pattern2[20] = vec2[]( 
    vec2(0.45,0.45),
    vec2(0.35,0.35),
    vec2(0.30,0.30),
    vec2(0.5,0.5),
    vec2(0.45,0.55),
    vec2(0.40,0.60),
    vec2(0.30,0.70),
    vec2(0.70,0.30),
    vec2(0.60,0.40),
    vec2(0.40,0.60),
    vec2(0.43,0.72),
    vec2(0.56,0.42),
    vec2(0.25,0.75),
    vec2(0.75,0.25),
    vec2(0.53,0.23),
    vec2(0.19,0.45),
    vec2(0.18,0.72),
    vec2(0.32,0.41),
    vec2(0.25,0.67),
    vec2(0.69,0.23)
);

void CreateImposter(vec3 position)
{
    vec3 scale = vec3(1.8, 0.8, 1.8);
	vec4 vertices[4];  
	vertices[0] = vec4(position.x + scale.x, position.y + 2 * scale.y, position.z + scale.z, 1.0f);  
	vertices[1] = vec4(position.x - scale.x, position.y + 2 * scale.y, position.z - scale.z, 1.0f);   
	vertices[2] = vec4(position.x + scale.x, position.y, position.z + scale.z, 1.0f);  
	vertices[3] = vec4(position.x - scale.x, position.y, position.z - scale.z, 1.0f);

    vec2 texCoords[4];
	texCoords[0] = vec2(0,0);
	texCoords[1] = vec2(1,0);
	texCoords[2] = vec2(0,1);
	texCoords[3] = vec2(1,1);

    // Output four vertices.
    int i;
    for(i = 0; i < 4; i++)
    {
        gl_Position = projectionMatrix * viewMatrix * vertices[i];
        vert_normal1 = gs_normal_in[0];
        vert_texcoord1 = texCoords[i];
        vert_color1 = vec3(0,0,1);
        EmitVertex();
    }
    
    EndPrimitive();   
}

void CreateQuad(vec3 position, float angle)
{
    vec4 unit = vec4(0,0,1,0);
    mat4 rotation;
	rotation[0] = vec4(cos(angle), 0, sin(angle), 0);
	rotation[1] = vec4(0, 1, 0, 0);
	rotation[2] = vec4(-sin(angle), 0, cos(angle), 0);
	rotation[3] = vec4(0, 0, 0, 1);   
    unit = rotation * unit;

    vec3 scale = vec3(1.8, 0.8, 1.8);
	vec4 vertices[4];  
	vertices[0] = vec4(position.x + unit.x * scale.x, position.y + 2 * scale.y, position.z + unit.z * scale.z, 1.0f);  
	vertices[1] = vec4(position.x - unit.x * scale.x, position.y + 2 * scale.y, position.z - unit.z * scale.z, 1.0f);   
	vertices[2] = vec4(position.x + unit.x * scale.x, position.y, position.z + unit.z * scale.z, 1.0f);  
	vertices[3] = vec4(position.x - unit.x * scale.x, position.y, position.z - unit.z * scale.z, 1.0f);

    vec2 texCoords[4];
	texCoords[0] = vec2(0,0);
	texCoords[1] = vec2(1,0);
	texCoords[2] = vec2(0,1);
	texCoords[3] = vec2(1,1);

    // Output four vertices.
    int i;
    for(i = 0; i < 4; i++)
    {
        gl_Position = projectionMatrix * viewMatrix * vertices[i];
        vert_texcoord1 = texCoords[i];
        vert_normal1 = gs_normal_in[0];
        EmitVertex();
    }
    
    EndPrimitive();   
}

void main() 
{
    float avgDensity = gs_density_in[0];
    
    if(gs_lod_in[0] == 0)
    {
        if(avgDensity > 0.1)
        {
            CreateMediumBlade3(gl_in[0].gl_Position.xyz);
        }     
    }
    else if(gs_lod_in[0] == 1)
    {
 
    }
    else
    {

    }
}